<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Prompt Structure — Config</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="/style.css" />
  <style>
    /* --- Styles for the Revamped Config UI --- */
    .block-item, .add-block-form {
      background-color: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-bottom: 1rem;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }
    .block-title {
      flex: 1;
      font-size: 1.1em;
    }
    .block-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    .block-actions .reorder-btns {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-right: 0.5rem;
    }
    .block-actions .reorder-btns button {
      line-height: 1;
      padding: 2px 6px;
    }
    .edit-form {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .edit-form .form-row {
      display: flex;
      gap: 0.5rem;
    }
    .edit-form .form-row input, .edit-form .form-row select {
      flex: 1;
      padding: 0.5rem;
    }
    .edit-form textarea {
      width: 100%;
      min-height: 150px;
      font-family: monospace;
      padding: 0.5rem;
      box-sizing: border-box; /* Important for 100% width */
    }
    .edit-form-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }
    .edit-form-actions .cancel-btn {
      background-color: #6c757d;
    }
    /* Hide edit form by default */
    .block-item .edit-form {
      display: none;
    }
    /* When editing, hide the header and show the form */
    .block-item.is-editing .block-header {
      display: none;
    }
    .block-item.is-editing .edit-form {
      display: flex;
    }
  </style>
</head>
<body>
  <main class="container">
    <h1>Prompt Structure — Config</h1>
    <p>
      Arrange and edit your prompt blocks. The immutable blocks (<strong>Character Info</strong>, <strong>User Persona</strong>, and <strong>Chat History</strong>) are special placeholders where parsed content from external apps will be injected. You can use <code>{{char}}</code> in your custom blocks to dynamically insert the character's name.
    </p>

    <div id="blocksList">Loading...</div>

    <hr />
    <h3>Add new block</h3>
    <div id="addBlockBox" class="add-block-form">
      <div class="form-row">
        <input id="new_name" placeholder="Name (eg. 'Assistant Persona')" />
        <select id="new_role">
          <option value="system">system</option>
          <option value="user">user</option>
          <option value="assistant">assistant</option>
        </select>
      </div>
      <textarea id="new_content" placeholder="Block content (string). Use {{char}} for the character's name."></textarea>
      <div class="edit-form-actions">
        <button id="btnAddBlock">Add block</button>
      </div>
    </div>

    <p><a href="/">Back to dashboard</a></p>
  </main>

  <script>
    const $ = id => document.getElementById(id);
    let proxyToken = localStorage.getItem('proxy_token') || null;
    if (!proxyToken) {
      alert('You must be logged in. Redirecting to home.');
      location.href = '/';
    }

    let allBlocks = [];

    async function api(path, opts = {}) {
      const headers = { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + proxyToken };
      const res = await fetch(path, { method: opts.method || 'GET', headers, body: opts.body ? JSON.stringify(opts.body) : undefined });
      const isJson = res.headers.get('content-type')?.includes('application/json');
      const data = isJson ? await res.json() : await res.text();
      if (!res.ok) throw data;
      return data;
    }

    function renderBlocks() {
      const html = allBlocks.map(b => {
        // For immutable blocks, we show their purpose instead of the placeholder content.
        const displayContent = b.immutable ? `(This block will be replaced by parsed content: ${b.name})` : (b.content || '');
        const editorContent = b.immutable ? '' : (b.content || '');

        return `
        <div class="block-item" id="block-${b.id}" data-id="${b.id}">
          <!-- View Mode -->
          <div class="block-header">
            <div class="block-title">
              <strong>${b.name}</strong> <small>(${b.role}) ${b.immutable ? '<em>immutable placeholder</em>' : ''}</small>
            </div>
            <div class="block-actions">
              <div class="reorder-btns">
                <button class="up-btn">↑</button>
                <button class="down-btn">↓</button>
              </div>
              ${b.immutable ? '' : `<button class="edit-btn">Edit</button><button class="del-btn">Delete</button>`}
            </div>
          </div>

          <!-- Edit Mode (hidden by default) -->
          <div class="edit-form">
            <div class="form-row">
              <input class="edit-name" value="${b.name}" placeholder="Name" />
              <select class="edit-role">
                <option value="system" ${b.role === 'system' ? 'selected' : ''}>system</option>
                <option value="user" ${b.role === 'user' ? 'selected' : ''}>user</option>
                <option value="assistant" ${b.role === 'assistant' ? 'selected' : ''}>assistant</option>
              </select>
            </div>
            <textarea class="edit-content" placeholder="Block content">${editorContent}</textarea>
            <div class="edit-form-actions">
              <button class="cancel-btn">Cancel</button>
              <button class="save-btn">Save</button>
            </div>
          </div>
        </div>
      `}).join('');
      $('blocksList').innerHTML = html || '<i>No blocks</i>';
      attachEventListeners();
    }

    function attachEventListeners() {
      document.querySelectorAll('.block-item').forEach(blockEl => {
        const blockId = blockEl.dataset.id;

        const upBtn = blockEl.querySelector('.up-btn');
        if (upBtn) upBtn.onclick = () => moveBlock(blockId, 'up');

        const downBtn = blockEl.querySelector('.down-btn');
        if (downBtn) downBtn.onclick = () => moveBlock(blockId, 'down');

        const delBtn = blockEl.querySelector('.del-btn');
        if (delBtn) delBtn.onclick = async () => {
          if (!confirm('Delete this block?')) return;
          await api('/api/config/' + blockId, { method: 'DELETE' });
          loadBlocks();
        };

        const editBtn = blockEl.querySelector('.edit-btn');
        if (editBtn) editBtn.onclick = () => {
          blockEl.classList.add('is-editing');
        };

        const cancelBtn = blockEl.querySelector('.cancel-btn');
        if (cancelBtn) cancelBtn.onclick = () => {
          blockEl.classList.remove('is-editing');
          renderBlocks();
        };

        const saveBtn = blockEl.querySelector('.save-btn');
        if (saveBtn) saveBtn.onclick = async () => {
          const newName = blockEl.querySelector('.edit-name').value;
          const newRole = blockEl.querySelector('.edit-role').value;
          const newContent = blockEl.querySelector('.edit-content').value;
          try {
            await api('/api/config/' + blockId, { method: 'PUT', body: { name: newName, role: newRole, content: newContent } });
            blockEl.classList.remove('is-editing');
            loadBlocks();
          } catch (err) {
            alert('Failed to save: ' + JSON.stringify(err));
          }
        };
      });
    }

    async function moveBlock(blockId, direction) {
      const id = Number(blockId);
      const order = allBlocks.map(b => b.id);
      const idx = order.indexOf(id);

      if (direction === 'up' && idx > 0) {
        [order[idx-1], order[idx]] = [order[idx], order[idx-1]];
      } else if (direction === 'down' && idx < order.length - 1) {
        [order[idx], order[idx+1]] = [order[idx+1], order[idx]];
      } else {
        return;
      }

      await api('/api/config/reorder', { method: 'POST', body: { order } });
      loadBlocks();
    }



    async function loadBlocks() {
      try {
        const j = await api('/api/config');
        allBlocks = j.blocks;
        renderBlocks();
      } catch (err) {
        console.error(err);
        $('blocksList').innerHTML = `<pre>${JSON.stringify(err, null, 2)}</pre>`;
      }
    }

    window.onload = () => {
      loadBlocks();
      $('btnAddBlock').onclick = async () => {
        const name = $('new_name').value;
        const role = $('new_role').value;
        const content = $('new_content').value;
        if (!name) {
          alert('Block name is required.');
          return;
        }
        try {
          await api('/api/config', { method: 'POST', body: { name, role, content } });
          $('new_name').value = '';
          $('new_content').value = '';
          $('new_role').value = 'system';
          loadBlocks();
        } catch (err) { alert(JSON.stringify(err)); }
      };
    };
  </script>
</body>
</html>